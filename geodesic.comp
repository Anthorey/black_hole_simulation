#include "config.h"

cbuffer UniformBuffer : register(b0, space2)
{
    float3 CameraPosition;
    float TanHalfFov;
    float3 CameraRight;
    float Aspect;
    float3 CameraUp;
    uint ObjectCount;
    float3 CameraForward;
    float DiskR1;
    float DiskR2;
};

struct Ray
{
    float3 Position;
    float R;
    float Theta;
    float Phi;
    float Dr;
    float Dtheta;
    float Dphi;
    float E;
    float L;
};

struct Object
{
    float3 Position;
    float Radius;
    float3 Color;
    float Mass;
};

[[vk::image_format("rgba8")]]
RWTexture2D<float4> outImage : register(u0, space1);
StructuredBuffer<Object> objects : register(t0, space0);

static const float kBlackHoleRadius = 1.269e10f; /* Sagittarius A */
static const float kLambda = 1.0e7f;
static const int kSteps = 60000;
static const float kEscape = 1.0e30f;

Ray CreateRay(float3 position, float3 direction)
{
    Ray ray;
    ray.Position = position;
    ray.R = length(position);
    ray.Theta = acos(position.z / ray.R);
    ray.Phi = atan2(position.y, position.x);
    float dx = direction.x;
    float dy = direction.y;
    float dz = direction.z;
    ray.Dr =
        sin(ray.Theta) * cos(ray.Phi) * dx +
        sin(ray.Theta) * sin(ray.Phi) * dy +
        cos(ray.Theta) * dz;
    ray.Dtheta = (
        cos(ray.Theta) * cos(ray.Phi) * dx +
        cos(ray.Theta) * sin(ray.Phi) * dy -
        sin(ray.Theta) * dz) / ray.R;
    ray.Dphi = (-sin(ray.Phi) * dx + cos(ray.Phi) * dy) / (ray.R * sin(ray.Theta));
    ray.L = ray.R * ray.R * sin(ray.Theta) * ray.Dphi;
    float f = 1.0f - kBlackHoleRadius / ray.R;
    float dt_dL =
        sqrt((ray.Dr * ray.Dr) / f +
        ray.R * ray.R * (ray.Dtheta * ray.Dtheta +
        sin(ray.Theta) * sin(ray.Theta) * ray.Dphi * ray.Dphi));
    ray.E = f * dt_dL;
    return ray;
}

void GeodesicRHS(Ray ray, out float3 d1, out float3 d2)
{
    float r = ray.R;
    float theta = ray.Theta;
    float dr = ray.Dr;
    float dtheta = ray.Dtheta;
    float dphi = ray.Dphi;
    float f = 1.0f - kBlackHoleRadius / r;
    float dt_dL = ray.E / f;
    d1 = float3(dr, dtheta, dphi);
    d2.x = -
        (kBlackHoleRadius / (2.0f * r * r)) * f * dt_dL * dt_dL +
        (kBlackHoleRadius / (2.0f * r * r * f)) * dr * dr +
        r * (dtheta * dtheta + sin(theta) * sin(theta) * dphi * dphi);
    d2.y = -2.0f * dr * dtheta / r + sin(theta) * cos(theta) * dphi * dphi;
    d2.z = -2.0f * dr * dphi / r - 2.0f * cos(theta) / sin(theta) * dtheta * dphi;
}

void Step(inout Ray ray, float dL)
{
    float3 k1a;
    float3 k1b;
    GeodesicRHS(ray, k1a, k1b);
    ray.R += dL * k1a.x;
    ray.Theta += dL * k1a.y;
    ray.Phi += dL * k1a.z;
    ray.Dr += dL * k1b.x;
    ray.Dtheta += dL * k1b.y;
    ray.Dphi += dL * k1b.z;
    ray.Position.x = ray.R * sin(ray.Theta) * cos(ray.Phi);
    ray.Position.y = ray.R * sin(ray.Theta) * sin(ray.Phi);
    ray.Position.z = ray.R * cos(ray.Theta);
}

[numthreads(THREADS, THREADS, 1)]
void main(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= WIDTH || id.y >= HEIGHT)
    {
        return;
    }
    float u = (2.0f * (id.x + 0.5f) / WIDTH - 1.0f) * Aspect * TanHalfFov;
    float v = (1.0f - 2.0f * (id.y + 0.5f) / HEIGHT) * TanHalfFov;
    float3 direction = normalize(u * CameraRight - v * CameraUp + CameraForward);
    Ray ray = CreateRay(CameraPosition, direction);
    float nearest = 0.0f;
    for (int i = 0; i < kSteps; i++)
    {
        if (ray.R <= kBlackHoleRadius)
        {
            outImage[id.xy] = float4(0.0f, 0.0f, 0.0f, 1.0f);
            return;
        }
        float3 position = ray.Position;
        Step(ray, kLambda);
        nearest -= distance(position, ray.Position);
        float r = length(float2(ray.Position.x, ray.Position.z));
        if (position.y * ray.Position.y < 0.0f && r >= DiskR1 && r <= DiskR2)
        {
            r = length(ray.Position) / DiskR2;
            outImage[id.xy] = float4(1.0f, r, 0.2f, r);
            return;
        }
        if (nearest < 0.0f)
        {
            nearest = kEscape;
            for (int i = 0; i < ObjectCount; i++)
            {
                float d = distance(ray.Position, objects[i].Position) - objects[i].Radius;
                nearest = min(nearest, d);
                if (d > 0.0f)
                {
                    continue;
                }
                float3 N = normalize(ray.Position - objects[i].Position);
                float3 V = normalize(CameraPosition - ray.Position);
                float ambient = 0.1f;
                float intensity = ambient + (1.0f - ambient) * max(dot(N, V), 0.0f);
                outImage[id.xy] = float4(objects[i].Color * intensity, 1.0f);
                return;
            }
        }
        if (ray.R > kEscape)
        {
            break;
        }
    }
    outImage[id.xy] = float4(0.0f, 0.0f, 0.0f, 0.0f);
}