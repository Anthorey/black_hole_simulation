#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct type_UniformBuffer
{
    packed_float3 CameraPosition;
    float TanHalfFov;
    packed_float3 CameraRight;
    float Aspect;
    packed_float3 CameraUp;
    uint ObjectCount;
    packed_float3 CameraForward;
    float DiskR1;
    float DiskR2;
};

struct Object
{
    packed_float3 Position;
    float Radius;
    packed_float3 Color;
    float Mass;
};

struct type_StructuredBuffer_Object
{
    Object _m0[1];
};

constant float3 _397 = {};

kernel void main0(constant type_UniformBuffer& UniformBuffer [[buffer(0)]], const device type_StructuredBuffer_Object& objects [[buffer(1)]], texture2d<float, access::write> outImage [[texture(0)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        bool _429;
        if (!(gl_GlobalInvocationID.x >= 200u))
        {
            _429 = gl_GlobalInvocationID.y >= 150u;
        }
        else
        {
            _429 = true;
        }
        if (_429)
        {
            break;
        }
        float3 _494 = fast::normalize(((float3(UniformBuffer.CameraRight) * (((((float(gl_GlobalInvocationID.x) + 0.5) * 0.00999999977648258209228515625) - 1.0) * UniformBuffer.Aspect) * UniformBuffer.TanHalfFov)) - (float3(UniformBuffer.CameraUp) * ((1.0 - ((float(gl_GlobalInvocationID.y) + 0.5) * 0.01333333365619182586669921875)) * UniformBuffer.TanHalfFov))) + float3(UniformBuffer.CameraForward));
        float _508 = length(float3(UniformBuffer.CameraPosition));
        float _516 = acos(UniformBuffer.CameraPosition[2] / _508);
        float _524 = precise::atan2(UniformBuffer.CameraPosition[1], UniformBuffer.CameraPosition[0]);
        float _528 = _494.x;
        float _532 = _494.y;
        float _536 = _494.z;
        float _540 = sin(_516);
        float _542 = cos(_524);
        float _548 = sin(_524);
        float _556 = cos(_516);
        float _560 = (((_540 * _542) * _528) + ((_540 * _548) * _532)) + (_556 * _536);
        float _578 = ((((_556 * _542) * _528) + ((_556 * _548) * _532)) - (_540 * _536)) / _508;
        float _592 = (((-_548) * _528) + (_542 * _532)) / (_508 * _540);
        float _596 = _508 * _508;
        float _606 = 1.0 - (12689999872.0 / _508);
        float _632 = _606 * sqrt(((_560 * _560) / _606) + (_596 * ((_578 * _578) + (((_540 * _540) * _592) * _592))));
        float3 _677;
        float3 _680;
        _677 = _397;
        _680 = float3(UniformBuffer.CameraPosition);
        float3 _678;
        float3 _681;
        float _687;
        float _689;
        float _691;
        float _693;
        float _695;
        float _697;
        bool _683;
        float _685;
        bool _1074;
        bool _682 = false;
        float _684 = 0.0;
        float _686 = _524;
        float _688 = _592;
        float _690 = _578;
        float _692 = _560;
        float _694 = _516;
        float _696 = _508;
        int _698 = 0;
        for (;;)
        {
            if (_698 < 60000)
            {
                if (_696 <= 12689999872.0)
                {
                    outImage.write(float4(0.0, 0.0, 0.0, 1.0), uint2(gl_GlobalInvocationID.xy));
                    _1074 = true;
                    break;
                }
                float _750 = 1.0 - (12689999872.0 / _696);
                float _754 = _632 / _750;
                float _760 = (2.0 * _696) * _696;
                float _782 = sin(_694);
                float _794 = ((((((-12689999872.0) / _760) * _750) * _754) * _754) + (((12689999872.0 / (_760 * _750)) * _692) * _692)) + (_696 * ((_690 * _690) + (((_782 * _782) * _688) * _688)));
                float _796 = (-2.0) * _692;
                float _802 = cos(_694);
                float _810 = ((_796 * _690) / _696) + (((_782 * _802) * _688) * _688);
                float _824 = ((_796 * _688) / _696) - ((((2.0 * _802) / _782) * _690) * _688);
                _678 = float3(_794, _810, _824);
                _697 = _696 + (10000000.0 * _692);
                _695 = _694 + (10000000.0 * _690);
                _687 = _686 + (10000000.0 * _688);
                _693 = _692 + (10000000.0 * _794);
                _691 = _690 + (10000000.0 * _810);
                _689 = _688 + (10000000.0 * _824);
                float _872 = _697 * sin(_695);
                float _876 = _872 * cos(_687);
                float _880 = _872 * sin(_687);
                float _884 = _697 * cos(_695);
                _681 = float3(_876, _880, _884);
                float _892 = _684 - distance(_680, _681);
                float _898 = length(float2(_876, _884));
                bool _918;
                if ((_680.y * _880) < 0.0)
                {
                    _918 = _898 >= UniformBuffer.DiskR1;
                }
                else
                {
                    _918 = false;
                }
                bool _930;
                if (_918)
                {
                    _930 = _898 <= UniformBuffer.DiskR2;
                }
                else
                {
                    _930 = false;
                }
                if (_930)
                {
                    float _942 = length(_681) / UniformBuffer.DiskR2;
                    outImage.write(float4(1.0, _942, 0.20000000298023223876953125, _942), uint2(gl_GlobalInvocationID.xy));
                    _1074 = true;
                    break;
                }
                if (_892 < 0.0)
                {
                    float _966;
                    float _1056;
                    bool _1057;
                    float _965 = 1000000015047466219876688855040.0;
                    int _968 = 0;
                    uint _973;
                    for (;;)
                    {
                        _973 = uint(_968);
                        if (_973 < UniformBuffer.ObjectCount)
                        {
                            float _995 = distance(_681, float3(objects._m0[_973].Position)) - objects._m0[_973].Radius;
                            _966 = precise::min(_965, _995);
                            if (_995 > 0.0)
                            {
                                _965 = _966;
                                _968++;
                                continue;
                            }
                            outImage.write(float4(float3(objects._m0[_973].Color) * (0.100000001490116119384765625 + (0.89999997615814208984375 * precise::max(dot(fast::normalize(_681 - float3(objects._m0[_973].Position)), fast::normalize(float3(UniformBuffer.CameraPosition) - _681)), 0.0))), 1.0), uint2(gl_GlobalInvocationID.xy));
                            _1056 = _966;
                            _1057 = true;
                            break;
                        }
                        else
                        {
                            _1056 = _965;
                            _1057 = _682;
                            break;
                        }
                    }
                    if (_1057)
                    {
                        _1074 = _1057;
                        break;
                    }
                    _685 = _1056;
                    _683 = _1057;
                }
                else
                {
                    _685 = _892;
                    _683 = _682;
                }
                if (_697 > 1000000015047466219876688855040.0)
                {
                    _1074 = _683;
                    break;
                }
                _677 = _678;
                _680 = _681;
                _682 = _683;
                _684 = _685;
                _686 = _687;
                _688 = _689;
                _690 = _691;
                _692 = _693;
                _694 = _695;
                _696 = _697;
                _698++;
                continue;
            }
            else
            {
                _1074 = _682;
                break;
            }
        }
        if (_1074)
        {
            break;
        }
        outImage.write(float4(0.0199999995529651641845703125, 0.0199999995529651641845703125, 0.0199999995529651641845703125, 1.0), uint2(gl_GlobalInvocationID.xy));
        break;
    } while(false);
}

